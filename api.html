<title>The BOINC Application Program Interface (API)</title> 
<h2>The BOINC Application Programming Interface (API)</h2>

The BOINC API is a library of C++ functions.
All the functions return an integer error code; zero indicates success.

<h3>Initialization and termination</h3>
An application must call
<pre>
    int boinc_init(bool is_main_program, char* app_preferences)
</pre>
before calling other BOINC functions or doing I/O.
<tt>is_main_program</tt> indicates whether the program
is the application's main program (normally true - see below).
The user's application-specific preferences, if any,
are returned in <tt>app_preferences</tt>.
When the application has completed successfully it must call
<pre>
    int boinc_finish();
</pre>
before exiting.
An application that encounters a fatal error must call
<pre>
    void exit(int error);
</pre>

<h3>Resolving file names</h3>
Applications that use named input or output files must call
<pre>
    int boinc_resolve_link(char *logical_name, char *physical_name);</tt>
</pre>
to convert logical file names to physical names.
For example, instead of
<pre>
    f = fopen("my_file", "r");
</pre>
</p>
the application might use
<p>
<pre>
    char resolved_name[256];
    retval = boinc_resolve_link("my_file", resolved_name);
    if (retval) fail("can't resolve filename");
    f = fopen(resolved_name, "r");
</pre>
<tt>boinc_resolve_link()</tt> doesn't need to be used for temporary files.

<h3>Checkpointing</h3>

Computations that use a significant amount of time
per work unit may want to periodically write the current
state of the computation to disk.
This is known as <b>checkpointing</b>.
The state file must include everything required
to start the computation again at the same place it was checkpointed.
On startup, the application
reads the state file to determine where to begin computation.
If the BOINC client quits or exits,
the computation can be restarted from the most recent checkpoint.

<p>
Do use checkpoint, an application should write to output and
state files using the <tt>MFILE</tt> class.
<pre>
class MFILE {
public:
    int open(char* path, char* mode);
    int _putchar(char);
    int puts(char*);
    int printf(char* format, ...);
    size_t write(const void* buf, size_t count);
    int close();
    int flush();
};
</pre>
MFILE buffers data in memory
and writes to disk only on <tt>flush()</tt> or <tt>close()</tt>.
This lets you write output files and state files
more or less atomically.
Frequency of checkpointing is a user preference
(e.g. laptop users might want to checkpoint infrequently).
An application must call
<pre>
bool time_to_checkpoint();
</pre>
whenever it reaches a point where it is able to checkpoint.
If this returns true,
the application should write the state file and flush all output files,
then call
<pre>
void checkpoint_completed();
</pre>

<h3>Fraction done</h3>
The core client GUI displays the percent done of workunits in progress.
To keep this display current, an application should
periodically call
<pre>
   boinc_percent_done(double fraction_done);
</pre>
The <tt>fraction_done</tt> argument is a rough estimate of the
workunit percentage complete.

<h3>Multi-program applications</h3>
Some applications consist of multiple programs:
a <b>main program</b> that acts as coordinator,
and one or more subsidiary programs.
Each program should use the BOINC API as described above,
using the appropriate argument to <tt>boinc_init()</tt>.
<p>
For checkpointing, each program has its own state file;
the state file of the coordinator program records
which subsidiary program was last active.
<p>
To correctly implement percent done,
the main program should pass information to subsidiary programs
(perhaps as command-line arguments) the starting and ending
fractions for that program.


<hr>
<h3>Implementation</h3>
<p>
Application are executed in separate "sandbox" directories,
allowing them to create and use temporary files without
concern about name conflicts.
Input and output files are kept outside the sandbox.
The mappings from virtual to physical filenames are
done using "symbolic link" files in the sandbox directory.
The name of such a file is the virtual name,
and it contains an XML tag with the physical name.
This scheme is necessary because of the lack of filesystem links
in Windows.

<p>
Communication between the core client and applications
is done through XML files in the sandbox directory.
Several files are used.
<p>
<b>Files created by the core client, read by the app:</b>
<ul>
<li> <b>boinc_init.xml</b>:
specifies the mappings of file descriptors (stdin/stdout/stderr)
to physical files.

<li> <b>core_to_app.xml</b>
    app prefs
    graphics settings (x/y, refresh rate)
    checkpoint period
    total CPU time previous (?)

</ul>
<p>
<b>Files created by the app, read by the core client:</b>
<ul>
<li>
<b>app_to_core.xml</b>
    percent done
    CPU time at last checkpoint
    checkpointed?

    written by checkpoint_completed
    read by core

</ul>
<p>
The implementation of the API uses timers
